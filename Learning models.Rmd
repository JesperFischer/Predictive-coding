---
title: "Learning models"
output: html_document
date: "2024-08-17"
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(cmdstanr)
register_knitr_engine(override = FALSE)

seeds = 123
set.seed(seeds)
```

## This markdown is supposed to highlight one of the main advantages of STAN. Models that have some temporal component (i.e. there are latent variables that depend on previous trials) can either be a pain or impossible to estimate in the "normal" framework of statistical modeling. However, with stan this becomes intuitive and easy!

### We start by simulating some data where participants learn cue-stimulus associations. For simplicity we simulate this association directly as 0 or 1's (these are what the simulated participants need to learn). In order to make it a dynamic learning experiment we can simulate that the association between the cue and stimulus changes with trials. Say the association starts bring 80% and then swaps to 20% after 20 trials.

```{r}

u = c(rbinom(30,1,0.8),rbinom(30,1,0.2),rbinom(30,1,0.8),rbinom(30,1,0.2))
plot(u)
```

### Theories of learning tell us that people update their belief in proportion to the prediction error. I.e., the more wrong you were, the more you update your beliefs. One conceptualization of this is the rescorla Wagner learning model which follows the mathematical update equation:

$$
\underbrace{E^{t+1}}_{\text{new expectation}} = \underbrace{E^{t}}_{\text{last expectation}}+\underbrace{\alpha}_{\text{Learning rate}}* \underbrace{(U^{t}-E^{t})}_{\text{prediction error}}
$$

### What this equation entails is that on each trial participants have an expectation (E(t)) that is compared to the actual input (U) and the difference between these two quantities are then multiplied by a subject level learning rate $\alpha$ which together gives how much ones belief is updated on a given trial.

### All that is needed is some assumption of a starting expectation for the model to run




```{r, echo = FALSE}

logis_sigmoid = function(expect,zeta){
  return(expect^zeta / (expect^zeta + (1-expect)^zeta))
}
get_hgf = function(u,e_0,zeta,omega,pi2_0){
  
  trial = length(u)
  mu2 = array(NA, trial)
  pi2 = array(NA, trial)
  sa2 = array(NA, trial)
  expect = array(NA, trial)
  
  mu2[1] = brms::logit_scaled(e_0)
  pi2[1] = pi2_0
  
  for(i in 1:trial){
    
    expect[i] = brms::inv_logit_scaled(mu2[i])
    sa2[i] = 1/pi2[i]
    pi2[i+1] = (1/(1/pi2[i] + (omega))) + 1/(1/(expect[i] * (1 - expect[i])))
    
    mu2[i+1] = mu2[i]+(1/pi2[i])*(u[i]-expect[i])
    
  }
  
  resp = rbinom(length(expect),1,logis_sigmoid(expect,zeta))
  data = data.frame(expect = expect, resp = resp) %>% mutate(omega = omega,pi2_0 = pi2_0, e_0 = e_0, zeta = zeta, model = "hgf") %>% 
    mutate(trial = 1:n(), u = u, lr = sa2)
  
  return(data)
}
get_rw = function(u,e_0,zeta,alpha){
  trial = length(u)
  expect2 = array(NA, trial)
  expect = array(NA, trial)
  
  expect[1] = (e_0)
  
  for(i in 1:trial){
    expect2[i] = expect[i]
    expect[i+1] = expect[i]+(alpha)*(u[i]-expect[i])
  }
  resp = rbinom(length(expect2),1,logis_sigmoid(expect2,zeta))
  data = data.frame(expect = expect2, resp = resp) %>% mutate(alpha = alpha, e_0 = e_0, zeta = zeta, model = "rw") %>% 
    mutate(trial = 1:n(), u = u,lr = alpha)
  
  
  return(data)
}
get_ph = function(u,e_0,zeta,S,a_0){
  trial = length(u)
  expect = array(NA, trial)
  expect2 = array(NA, trial)
  
  expect[1] = (e_0)
  
  for(i in 1:trial){
    expect2[i] = expect[i]
    if(i == 1){
      expect[i+1] = expect[i]+(S)*(u[i]-expect[i]) * a_0
    }else{
      expect[i+1] = expect[i]+(S)*(u[i]-expect[i]) * abs((u[i-1] - expect[i-1]))
    }
  }
  resp = rbinom(length(expect2),1,logis_sigmoid(expect2,zeta))
  data = data.frame(expect = expect2, resp = resp) %>% mutate(S = S, a_0 = a_0, e_0 = e_0, zeta = zeta, model = "ph") %>% 
    mutate(trial = 1:n(), u = u, lr = S*abs((u - expect)))
  
  return(data)
}
get_su1 = function(u,e_0,zeta,mu,Rhat,h_0){
  
  trial = length(u)
  expect2 = array(NA, trial)
  expect = array(NA, trial)
  be = array(NA,trial)
  al = array(NA,trial)
  h = array(NA,trial)
  
  expect[1] = (e_0)
  be[1] = log(Rhat)
  h[1] = h_0
  
  for(i in 1:trial){
    
    expect2[i] = expect[i]
    
    be[i+1] = be[i] + mu * (u[i]-expect[i])*h[i]
    al[i] = exp(be[i]) / (Rhat + exp(be[i]))
    h[i+1] = (h[i] + al[i] * (u[i]-expect[i])) * max((1-al[i]),0)
    
    
    expect[i+1] = expect[i] + al[i] * (u[i]-expect[i]);
    
  }
  
  
  resp = rbinom(length(expect2),1,logis_sigmoid(expect2,zeta))
  data = data.frame(expect = expect2, resp = resp) %>% mutate(mu = mu, Rhat = Rhat, h_0 = h_0, e_0 = e_0, zeta = zeta, model = "su1") %>% 
    mutate(trial = 1:n(), u = u,lr = al)
  
  return(data)
}




make_plot = function(data, model_name){
  
  p1 = ggplot(data, aes(x = trial, y = expect)) +
    geom_line() +
    geom_point(aes(y = u)) +
    labs(x = "Trial", y = "Value", title = paste0(model_name," Plot")) +
    theme_minimal()
  
  lr = ggplot(data, aes(x = trial, y = lr)) +
    geom_line() +
    labs(x = "Trial", y = "Value", title = ("Learning rate")) +
    theme_minimal()
  
  return(p1)
  
}


trial = length(u)

# Define UI for the application
ui <- fluidPage(
  
  # Application title
  titlePanel("Shiny App for the various learning models"),
  
  # Define a sidebar layout with input and output
  sidebarLayout(
    sidebarPanel(
      # Navigation bar for different pages
      navlistPanel(
        id = "nav",  # Assign an ID to track the selected tab
        "Learning models",
        tabPanel("rw", 
                 sliderInput("e_0_rw", "e_0", min = 0, max = 1, value = 0.5),
                 sliderInput("alpha_rw", "alpha", min = 0, max = 1, value = 0.1)
        ),
        tabPanel("hgf", 
                 sliderInput("e_0_hgf", "e_0", min = 0, max = 1, value = 0.5),
                 sliderInput("zeta_hgf", "zeta", min = 0, max = 100, value = 10),
                 sliderInput("omega_hgf", "omega", min = 0, max = 1.5, value = 0.5),
                 sliderInput("pi2_0_hgf", "pi2_0", min = 0, max = 100, value = 0.5)
        ),
        tabPanel("ph", 
                 sliderInput("e_0_ph", "e_0", min = 0, max = 1, value = 0.5),
                 sliderInput("zeta_ph", "zeta", min = 0, max = 100, value = 10),
                 sliderInput("S_ph", "S", min = 0, max = 1, value = 0.1),
                 sliderInput("a_0_ph", "a_0", min = 0, max = 1, value = 0.01)
        ),
        tabPanel("su1", 
                 sliderInput("e_0_su1", "e_0", min = 0, max = 1, value = 0.5),
                 sliderInput("zeta_su1", "zeta", min = 0, max = 100, value = 10),
                 sliderInput("mu_su1", "mu", min = 0, max = 15, value = 0.1),
                 sliderInput("Rhat_su1", "Rhat", min = 0, max = 1, value = 0.01),
                 sliderInput("h_0_su1", "h_0", min = -10, max = 10, value = 0.1)
        )
      )
    ),
    
    # Main panel for displaying outputs
    mainPanel(
      uiOutput("main_plot")
    )
  )
)


server <- function(input, output, session) {
  
  output$main_plot <- renderUI({
    tab_name <- input$nav
    plotOutput(tab_name)
  })
  
  output$rw <- renderPlot({
    data <- get_rw(u, input$e_0_rw, 10, input$alpha_rw)
    
    make_plot(data,"RW")
    
  })
  
  output$hgf <- renderPlot({
    data <- get_hgf(u, input$e_0_hgf, input$zeta_hgf, input$omega_hgf, input$pi2_0_hgf)
    
    make_plot(data,"HGF")
  })
  
  
  output$ph <- renderPlot({
    data <- get_ph(u, input$e_0_ph, input$zeta_ph, input$S_ph,input$a_0_ph)
    
    make_plot(data,"ph")
    
  })
  
  output$su1 <- renderPlot({
    data <- get_su1(u, input$e_0_su1, input$zeta_su1, input$mu_su1, input$Rhat_su1, input$h_0_su1)
    
    make_plot(data,"SU1")
  })
  
}


# Run the application 
shinyApp(ui = ui, server = server,options = list(height = 1200, width = 1200))

```



### The only thing that is needed now is to transform the trial by trial expectations into binary responses this is done through the bernoulli distribution.

### Simulating an agent with a particular starting expectation and learning rate and thus his responses entails:

```{r}
e_0 = 0.5
alpha = 0.25


trial = length(u)
expect2 = array(NA, trial)
expect = array(NA, trial)

expect[1] = (e_0)

for(i in 1:trial){
  expect2[i] = expect[i]
  expect[i+1] = expect[i]+(alpha)*(u[i]-expect[i])
}

resp = rbinom(length(expect2),1,expect2)

data = data.frame(expect = expect2, resp = resp) %>% mutate(alpha = alpha, e_0 = e_0, model = "rw") %>% 
  mutate(trial = 1:n(), u = u,lr = alpha)


ggplot(data, aes(x = trial, y = expect)) +
  geom_line() +
  geom_point(aes(y = u))+
  geom_point(aes(y = resp+0.05), col = "red")
  
```



